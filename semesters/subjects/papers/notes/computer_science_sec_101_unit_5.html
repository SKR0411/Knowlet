<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="description" content="Comprehensive notes for SEC 101: Unit 5 - I/O, Files & Low-Level Programming. Includes key concepts, definitions, and summaries for college students.">
    <meta name="keywords" content="101, files, lowlevel, programming, sec, unit">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEC 101: Unit 5 - I/O, Files & Low-Level Programming</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; margin: 20px; background-color: #f0f8ff; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #00796B; border-bottom: 2px solid #00796B; padding-bottom: 5px; }
        h1 { font-size: 2.2em; text-align: center; }
        h2 { font-size: 1.8em; margin-top: 30px; }
        h3 { font-size: 1.4em; color: #004D40; border-bottom: 1px solid #004D40; }
        strong { color: #d9534f; }
        code { background: #e0f7fa; border: 1px solid #b2ebf2; padding: 2px 6px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; }
        blockquote { background: #e0f7fa; border-left: 5px solid #00796B; margin: 20px 0; padding: 15px; font-style: italic; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #00796B; color: white; text-align: center; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .toc { background: #f8f9fa; border: 1px solid #dee2e6; padding: 15px; border-radius: 5px; margin-bottom: 30px; }
        .toc h2 { border: none; margin-top: 0; }
        .toc ul { list-style-type: none; padding: 0; }
        .toc li a { text-decoration: none; color: #007bff; }
        .toc li a:hover { text-decoration: underline; }
        .exam-tip { background: #fff3cd; border: 1px solid #ffeeba; border-left-width: 5px; padding: 15px; margin: 15px 0; border-radius: 5px; }
    </style>
</head>
<body>

<div class="container">
    <h1>Unit 5: Input/Output, Files, and Low-Level Programming</h1>

    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <span id="span_74"><li><a href="#stdio">5.1 Standard Input and Output</a></span></li>
            <span id="span_75"><li><a href="#files">5.2 Data Files</a></span></li>
            <span id="span_76"><li><a href="#low-level">5.3 Low-Level Programming</a></span></li>
            <span id="span_77"><li><a href="#advanced">5.4 Advanced Topics (Macros, Library)</a></span></li>
        </ul>
    </div>

    <span id="span_78"><h2 id="stdio">5.1 Standard Input and Output</span></h2>
    <p>Refers to I/O from the default console (keyboard for input, screen for output).</p>
    
    <span id="span_79"><h3>Formatted Output (<code>printf</code>)</span></h3>
    <p>Provides fine-grained control over output format.</p>
    <pre><code>printf("Item: %-10s Price: %7.2f\n", "Apple", 1.2);
// %-10s: Left-justify string in a 10-char-wide field
// %7.2f: Right-justify float in a 7-char-wide field with 2 decimal places
</code></pre>
    
    <span id="span_80"><h3>Formatted Input (<code>scanf</code>)</span></h3>
    <p>Reads formatted input. Its return value is the number of items successfully read.</p>
    <div class="exam-tip"><code>scanf</code> can be tricky. It often leaves the newline character (<code>\n</code>) in the input buffer, which can cause problems for subsequent <code>scanf</code> or <code>gets</code> calls.</div>
    
    <span id="span_81"><h3>Variable Length Arguments</span></h3>
    <p>This is the mechanism that allows <code>printf</code> and <code>scanf</code> to take a variable number of arguments. It is an advanced feature implemented using the <code>&lt;stdarg.h&gt;</code> header.</p>

    <span id="span_82"><h2 id="files">5.2 Data Files</span></h2>
    <p>File I/O allows your program to read from and write to files on disk, making data persistent.</p>
    
    <span id="span_83"><h3>Opening and Closing a File</span></h3>
    <p>You use a <code>FILE</code> pointer. <code>fopen()</code> opens a file and <code>fclose()</code> closes it.</p>
    <table>
        <tr><th>Mode</th><th>Description</th></tr>
        <tr><td><code>"r"</code></td><td><strong>Read:</strong> Open an existing file for reading.</td></tr>
        <tr><td><code>"w"</code></td><td><strong>Write:</strong> Create a new file for writing. (Overwrites existing)</td></tr>
        <tr><td><code>"a"</code></td><td><strong>Append:</strong> Open or create a file to write at the end.</td></tr>
        <tr><td><code>"r+"</code>, <code>"w+"</code>, <code>"a+"</code></td><td>Read and Write modes.</td></tr>
    </table>
    <pre><code>FILE *fp;
fp = fopen("data.txt", "w"); // Create/open "data.txt" in write mode
if (fp == NULL) {
    printf("Error opening file!\n");
    return 1; // Exit
}
// ... do file operations ...
fclose(fp); // Always close the file</code></pre>

    <span id="span_84"><h3>Processing a Data File (Formatted)</span></h3>
    <p>These functions work just like <code>printf/scanf</code> but for files.</p>
    <ul>
        <li><strong><code>fprintf(fp, "...", ...)</code>:</strong> Writes formatted text to a file.</li>
        <li><strong><code>fscanf(fp, "...", ...)</code>:</strong> Reads formatted text from a file.</li>
    </ul>

    <span id="span_85"><h3>Unformatted Data Files (Binary)</span></h3>
    <p>Used for reading/writing raw binary data (like an array or a struct) directly to a file. Much faster and more efficient for non-text data.</p>
    <ul>
        <li><strong><code>fwrite(ptr, size, count, fp)</code>:</strong> Writes <code>count</code> items of <code>size</code> from <code>ptr</code> to <code>fp</code>.</li>
        <li><strong><code>fread(ptr, size, count, fp)</code>:</strong> Reads <code>count</code> items of <code>size</code> from <code>fp</code> into <code>ptr</code>.</li>
    </ul>

    <span id="span_86"><h3>Miscellaneous Functions</span></h3>
    <ul>
        <li><strong><code>feof(fp)</code>:</strong> Returns true if the end-of-file has been reached.</li>
        <li><strong><code>fseek(fp, offset, whence)</code>:</strong> Moves the file pointer to a specific location (for random file access).</li>
    </ul>

    <span id="span_87"><h2 id="low-level">5.3 Low-Level Programming</span></h2>
    
    <span id="span_88"><h3>Register Variables</span></h3>
    <p><code>register int x;</code></p>
    <p>This is a <strong>hint</strong> to the compiler to store this variable in a CPU register for faster access. Modern compilers are very good at optimization and often ignore this keyword.</p>

    <span id="span_89"><h3>Bitwise Operations</span></h3>
    <p>Operations that manipulate data at the individual bit level. Essential for hardware control, data compression, and encryption.</p>
    <table>
        <tr><th>Operator</th><th>Name</th><th>Example (a=5, b=3)</th><th>Result</th></tr>
        <tr><td><code>&</code></td><td>Bitwise AND</td><td><code>0101 & 0011</code></td><td><code>0001</code> (1)</td></tr>
        <tr><td><code>|</code></td><td>Bitwise OR</td><td><code>0101 | 0011</code></td><td><code>0111</code> (7)</td></tr>
        <tr><td><code>^</code></td><td>Bitwise XOR</td><td><code>0101 ^ 0011</code></td><td><code>0110</code> (6)</td></tr>
        <tr><td><code>~</code></td><td>Bitwise NOT</td><td><code>~0101</code></td><td><code>1010</code> (Depends on size)</td></tr>
        <tr><td><code><<</code></td><td>Left Shift</td><td><code>0101 << 1</code></td><td><code>1010</code> (10)</td></tr>
        <tr><td><code>>></code></td><td>Right Shift</td><td><code>0101 >> 1</code></td><td><code>0010</code> (2)</td></tr>
    </table>
    
    <span id="span_90"><h3>Bit Fields</span></h3>
    <p>Allow you to pack data into a structure to save memory, specifying the exact number of bits for each member.</p>
    <pre><code>struct Flags {
    unsigned int isActive : 1;  // Use only 1 bit
    unsigned int isDirty : 1;   // Use only 1 bit
    unsigned int mode : 2;      // Use only 2 bits
};</code></pre>

    <span id="span_91"><h3>Enumeration (<code>enum</code>)</span></h3>
    <p>A user-defined type consisting of a set of named integer constants. Improves code readability.</p>
    <pre><code>enum Day { MON = 1, TUE, WED, THU, FRI, SAT, SUN };
enum Day today = WED;
if (today == 3) { // true
    printf("It's Wednesday!\n");
}</code></pre>

    <span id="span_92"><h2 id="advanced">5.4 Advanced Topics (Macros, Library)</span></h2>
    
    <span id="span_93"><h3>Command Line Arguments/Parameters</span></h3>
    <p>This topic is also listed in Unit 3. It refers to <code>main(int argc, char *argv[])</code>, allowing the program to accept parameters from the command line.</p>
    
    <span id="span_94"><h3>Library Functions</span></h3>
    <p>The C Standard Library provides a rich set of functions, e.g.:</p>
    <ul>
        <li><code>&lt;string.h&gt;</code>: <code>strcpy</code>, <code>strlen</code>, <code>strcmp</code></li>
        <li><code>&lt;stdlib.h&gt;</code>: <code>malloc</code>, <code>free</code>, <code>exit</code>, <code>rand</code></li>
        <li><code>&lt;math.h&gt;</code>: <code>sqrt</code>, <code>pow</code>, <code>sin</code></li>
    </ul>

    <span id="span_95"><h3>Macros (The C Preprocessor)</span></h3>
    <p>This topic is also listed in Unit 2. <code>#define</code> is used to create constants and function-like macros. The preprocessor also supports <strong>conditional compilation</strong>:</p>
    <pre><code>#define DEBUG
...
#ifdef DEBUG
    printf("Debug message: x = %d\n", x);
#endif</code></pre>
</div>

</body>
</html>
