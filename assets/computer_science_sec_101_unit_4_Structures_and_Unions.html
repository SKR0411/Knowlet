<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEC 101: Unit 4 - Structures and Unions</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; margin: 20px; background-color: #f0f8ff; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #00796B; border-bottom: 2px solid #00796B; padding-bottom: 5px; }
        h1 { font-size: 2.2em; text-align: center; }
        h2 { font-size: 1.8em; margin-top: 30px; }
        h3 { font-size: 1.4em; color: #004D40; border-bottom: 1px solid #004D40; }
        strong { color: #d9534f; }
        code { background: #e0f7fa; border: 1px solid #b2ebf2; padding: 2px 6px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; }
        blockquote { background: #e0f7fa; border-left: 5px solid #00796B; margin: 20px 0; padding: 15px; font-style: italic; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #00796B; color: white; text-align: center; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .toc { background: #f8f9fa; border: 1px solid #dee2e6; padding: 15px; border-radius: 5px; margin-bottom: 30px; }
        .toc h2 { border: none; margin-top: 0; }
        .toc ul { list-style-type: none; padding: 0; }
        .toc li a { text-decoration: none; color: #007bff; }
        .toc li a:hover { text-decoration: underline; }
        .exam-tip { background: #fff3cd; border: 1px solid #ffeeba; border-left-width: 5px; padding: 15px; margin: 15px 0; border-radius: 5px; }
    </style>
</head>
<body>

<div class="container">
    <h1>Unit 4: Structures and Unions</h1>

    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            [span_56](start_span)<li><a href="#struct-basics">4.1 Structures: Basics and Processing</a>[span_56](end_span)</li>
            [span_57](start_span)<li><a href="#struct-adv">4.2 Structures with Pointers and Functions</a>[span_57](end_span)</li>
            [span_58](start_span)<li><a href="#struct-arrays">4.3 Arrays of Structures and Self-Reference</a>[span_58](end_span)</li>
            [span_59](start_span)<li><a href="#unions">4.4 UNIONS</a>[span_59](end_span)</li>
            [span_60](start_span)<li><a href="#problem-solving">4.5 Problem Solving with Structures and Unions</a>[span_60](end_span)</li>
        </ul>
    </div>

    [span_61](start_span)<h2 id="struct-basics">4.1 Structures: Basics and Processing[span_61](end_span)</h2>
    <p>A <strong>structure</strong> is a user-defined data type that groups together related variables of <strong>different data types</strong>.</p>
    
    [span_62](start_span)<h3>Basics of Structures[span_62](end_span)</h3>
    <pre><code>// 1. Definition
struct Student {
    char name[50];
    int rollNumber;
    float gpa;
};

int main() {
    // 2. Variable declaration
    struct Student s1;

    // 3. Processing (Accessing members with dot .)
    strcpy(s1.name, "Alex");
    s1.rollNumber = 101;
    s1.gpa = 8.5;

    printf("Name: %s\n", s1.name);
    return 0;
}</code></pre>

    [span_63](start_span)<h3>User-defined data types (<code>typedef</code>)[span_63](end_span)</h3>
    <p><code>typedef</code> creates an alias (a new name) for an existing data type. It simplifies structure declarations.</p>
    <pre><code>// Using typedef with struct
typedef struct {
    char name[50];
    int rollNumber;
    float gpa;
} Student; // 'Student' is now the new type name

int main() {
    Student s1; // Much cleaner than 'struct Student s1'
    s1.rollNumber = 101;
}</code></pre>

    [span_64](start_span)<h2 id="struct-adv">4.2 Structures with Pointers and Functions[span_64](end_span)</h2>
    
    [span_65](start_span)<h3>Structures and Pointers[span_65](end_span)</h3>
    <p>You can have a pointer to a structure. To access members from a structure pointer, you use the <strong>arrow operator (<code>-></code>)</strong>.</p>
    <pre><code>Student s1;
Student *ptr = &s1; // ptr points to s1

// Accessing members
ptr->rollNumber = 102; // Same as (*ptr).rollNumber
strcpy(ptr->name, "Maria");</code></pre>
    <div class="exam-tip"><code>s.member</code> (if <code>s</code> is a structure) vs. <code>ptr->member</code> (if <code>ptr</code> is a pointer to a structure). This is a very common point of confusion.</div>

    [span_66](start_span)<h3>Structures and Functions[span_66](end_span)</h3>
    <p>It's highly recommended to pass structures to functions using <strong>pointers</strong> to avoid the inefficiency of copying the entire structure (which is the default pass-by-value behavior).</p>
    <pre><code>// Good practice: Pass by pointer
void printStudent(Student *s) {
    printf("Name: %s\n", s->name);
    printf("Roll: %d\n", s->rollNumber);
}

int main() {
    Student s1 = {"Alex", 101, 8.5};
    printStudent(&s1); // Pass the address
}</code></pre>

    [span_67](start_span)<h2 id="struct-arrays">4.3 Arrays of Structures and Self-Reference[span_67](end_span)</h2>
    
    [span_68](start_span)<h3>Arrays of Structures[span_68](end_span)</h3>
    <p>You can create an array where each element is a structure. This is perfect for storing records.</p>
    <pre><code>Student class[60]; // An array of 60 Student structures
class[0].rollNumber = 101;
strcpy(class[0].name, "Alex");</code></pre>
    [span_69](start_span)<p>This is often used for <strong>Table Lookup</strong>, where you search the array for a record matching a key.[span_69](end_span)</p>

    [span_70](start_span)<h3>Pointers to Structures[span_70](end_span)</h3>
    <p>This concept (covered in 4.2) is fundamental to managing arrays of structures and self-referential structures.</p>
    
    [span_71](start_span)<h3>Self-referential Structures[span_71](end_span)</h3>
    <p>A structure that contains a pointer to itself (of the same structure type). This is the fundamental building block for data structures like <strong>Linked Lists</strong> and Trees.</p>
    <pre><code>// A node in a linked list
typedef struct Node {
    int data;
    struct Node *next; // Pointer to the next node in the list
} Node;</code></pre>

    [span_72](start_span)<h2 id="unions">4.4 UNIONS[span_72](end_span)</h2>
    <p>A <strong>union</strong> is a user-defined type where all members share the <strong>same memory location</strong>. Only one member can be active and contain a value at any given time.</p>
    <pre><code>typedef union {
    int i;
    float f;
    char c;
} Data;

int main() {
    Data d;
    d.i = 10;
    printf("i: %d\n", d.i);   // Prints 10
    
    d.f = 220.5;
    printf("f: %.1f\n", d.f); // Prints 220.5
    
    // Previous 'i' value is now corrupted!
    printf("i: %d\n", d.i);   // Prints garbage/corrupted value
}</code></pre>

    [span_73](start_span)<h2 id="problem-solving">4.5 Problem Solving with Structures and Unions[span_73](end_span)</h2>
    <blockquote>
        <strong>Structure vs. Union: Key Difference</strong>
        <ul>
            <li><strong><code>struct</code>:</strong> Stores <strong>ALL</strong> members. Memory size is the <strong>SUM</strong> of all member sizes (plus padding). Use when you need to store multiple values together.</li>
            <li><strong><code>union</code>:</strong> Stores only <strong>ONE</strong> member at a time. Memory size is the size of the <strong>LARGEST</strong> member. Use when you need to store one of several possible types in a single space.</li>
        </ul>
    </blockquote>
</div>

</body>
</html>
